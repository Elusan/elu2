
#' @name calc.gamma
#' @title Calculate gamma from n
#' @param n Exponent of the Pella-Tomlinson surplus production equation.
#' @export
calc.gamma <- function(n) n^(n/(n-1)) / (n-1)


#' @name get.par
#' @title Extract parameters from a result report as generated by fit.spict.
#' @details \code{get.par} is a helper function for extracting the value and
#'     uncertainty of a specific model parameter, random effect or derived
#'     quantity. \code{list.quantities} gives the names of all quantities.
#' @param parname Character string containing the name of the variable of
#'     interest.
#' @param rep A result report as generated by running \code{fit.spict}.
#' @param exp Take exp of the variable? TRUE/FALSE.
#' @param CI Confidence intervals to be calculated, e.g. 0.9 for the 90\%
#'     confidence intervals. By default (CI = 0.95), the 95\% confidence
#'     intervals are estimated.
#' @param random DUMMY not used anymore. (Is the variable a random effect?
#'     TRUE/FALSE.)
#' @param fixed DUMMY not used anymore. (Is the variable a fixed effect?
#'     TRUE/FALSE.)
#' @return get.par returns a matrix with four columns containing respectively:
#'     1) the lower 95\% confidence limit; 2) the parameter estimate; 3) the
#'     upper 95\% confidence limit; 4) the parameter standard deviation in the
#'     domain it was estimated (log or non-log). `list.quantities` returns a
#'     vector with the names of all estimated parameters and derived quantities.
#' @examples
#' ## Run the South Atlantic albacore assessment
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#'
#' ## See all quantitites that can be extracted
#' list.quantities(rep)
#'
#' ## Extract the Bmsy reference point
#' Bmsy <- get.par('logBmsy', rep, exp=TRUE)
#'
#' ## Extract the exploitable biomass estimates
#' Best <- get.par('logB', rep, exp=TRUE)
#'
#' ## Extract the estimated carrying capacity
#' K <- get.par('logK', rep, exp=TRUE)
#' @export
get.par <- function(parname, rep=rep, exp=FALSE, random=FALSE, fixed=FALSE, CI = 0.95){
  if(CI > 1 || CI < 0) stop("CI has to be between 0 and 1!")
  zscore <- qnorm(CI + (1 - CI)/2)
  if (!'sderr' %in% names(rep)){
    indran <- which(names(rep$par.random)==parname)
    indfix <- which(names(rep$par.fixed)==parname)
    indsdr <- which(names(rep$value)==parname)
    indopt <- which(names(rep$opt$par)==parname)
    est <- NULL
    if (length(indran)>0){
      est <- rep$par.random[indran]
      sd <- sqrt(rep$diag.cov.random[indran])
      ll <- est - zscore*sd
      ul <- est + zscore*sd
    }
    if (length(indfix)>0){
      est <- rep$par.fixed[indfix]
      sd <- sqrt(diag(rep$cov.fixed))[indfix]
      ll <- est - zscore*sd
      ul <- est + zscore*sd
    }
    if (length(indsdr)>0){
      est <- rep$value[indsdr]
      sd <- rep$sd[indsdr]
      ll <- est - zscore*sd
      ul <- est + zscore*sd
    }
    if (length(est)==0){
      ll <- NA
      ul <- NA
      sd <- NA
      est <- NA
      if (length(indopt)>0){
        est <- rep$opt$par[indopt]
      } else {
        if ('phases' %in% names(rep$inp)){
          if (parname %in% names(rep$inp$phases)){
            if (rep$inp$phases[[parname]] == -1){
              est <- rep$inp$parlist[[parname]]
              ll <- est
              ul <- est
            }
          }else {
            if (!is.na(parname) && parname == 'P'){
              B <- get.par('logB', rep, exp=TRUE, CI = CI)
              C <- get.par('logCpred', rep, exp=TRUE, CI = CI)
              ic <- rep$inp$ic
              nc <- rep$inp$nc
              B0 <- B[ic, 2]
              B1 <- B[ic+nc, 2]
              T0 <- rep$inp$time[ic]
              T1 <- rep$inp$time[ic+nc]
              # Get annual average
              est <- (B1 - B0 + C[, 2]) / (T1-T0)
            }
          }
        } else {
          warning('get.par WARNING: could not extract ', parname)
        }
      }
    }
    if (exp==TRUE){
      # This is the CV of a log-normally distributed random variable
      # see https:/ /en.wikipedia.org/wiki/Log-normal_distribution
      cv <- sqrt(exp(sd^2) - 1)
      ll <- exp(ll)
      ul <- exp(ul)
      ul[ul == Inf] <- exp(705) # Put a large but finite value instead of Inf
      est <- exp(est)
    } else {
      cv <- sd/est
    }
    out <- cbind(ll, est, ul, sd, cv)
    if (parname %in% c('logB', 'logF', 'logBBmsy', 'logFFmsy')){
      rownames(out) <- rep$inp$time
    }
    return(out)
  }
}
