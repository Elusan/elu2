#' @name check.rep
#' @title Check rep list
#' @param rep A result report as generated by running \code{fit.spict}.
#' @param reportmode0 Should it be checked that the reportmode is 0 (default: TRUE).
#' @details Internal function that checks if rep is fitted spict object.
#' @return Nothing
check.rep <- function(rep, reportmode0 = TRUE){
  if(!inherits(rep, "spictcls") || !"opt" %in% names(rep)){
    stop("The argument 'rep' needs to be a fitted spict object. Use 'fit.spict()' to fit a spict model!")
  }else if(reportmode0 && rep$inp$reportmode != 0){
    stop("All states of the spict model need to be reported! Set the argument 'inp$reportmode' to 0 and fit spict
 again!")
  }
  return(TRUE)
}


#' @name get.par
#' @title Extract parameters from a result report as generated by fit.spict.
#' @details \code{get.par} is a helper function for extracting the value and
#'     uncertainty of a specific model parameter, random effect or derived
#'     quantity. \code{list.quantities} gives the names of all quantities.
#' @param parname Character string containing the name of the variable of
#'     interest.
#' @param rep A result report as generated by running \code{fit.spict}.
#' @param exp Take exp of the variable? TRUE/FALSE.
#' @param CI Confidence intervals to be calculated, e.g. 0.9 for the 90\%
#'     confidence intervals. By default (CI = 0.95), the 95\% confidence
#'     intervals are estimated.
#' @param random DUMMY not used anymore. (Is the variable a random effect?
#'     TRUE/FALSE.)
#' @param fixed DUMMY not used anymore. (Is the variable a fixed effect?
#'     TRUE/FALSE.)
#' @return get.par returns a matrix with four columns containing respectively:
#'     1) the lower 95\% confidence limit; 2) the parameter estimate; 3) the
#'     upper 95\% confidence limit; 4) the parameter standard deviation in the
#'     domain it was estimated (log or non-log). `list.quantities` returns a
#'     vector with the names of all estimated parameters and derived quantities.
#' @export
#' @examples
#' ## Run the South Atlantic albacore assessment
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#'
#' ## See all quantitites that can be extracted
#' list.quantities(rep)
#'
#' ## Extract the Bmsy reference point
#' Bmsy <- get.par('logBmsy', rep, exp=TRUE)
#'
#' ## Extract the exploitable biomass estimates
#' Best <- get.par('logB', rep, exp=TRUE)
#'
#' ## Extract the estimated carrying capacity
#' K <- get.par('logK', rep, exp=TRUE)
get.par <- function(parname, rep=rep, exp=FALSE, random=FALSE, fixed=FALSE, CI = 0.95){
  if(CI > 1 || CI < 0) stop("CI has to be between 0 and 1!")
  zscore <- qnorm(CI + (1 - CI)/2)
  if (!'sderr' %in% names(rep)){
    indran <- which(names(rep$par.random)==parname)
    indfix <- which(names(rep$par.fixed)==parname)
    indsdr <- which(names(rep$value)==parname)
    indopt <- which(names(rep$opt$par)==parname)
    est <- NULL
    if (length(indran)>0){
      est <- rep$par.random[indran]
      sd <- sqrt(rep$diag.cov.random[indran])
      ll <- est - zscore*sd
      ul <- est + zscore*sd
    }
    if (length(indfix)>0){
      est <- rep$par.fixed[indfix]
      sd <- sqrt(diag(rep$cov.fixed))[indfix]
      ll <- est - zscore*sd
      ul <- est + zscore*sd
    }
    if (length(indsdr)>0){
      est <- rep$value[indsdr]
      sd <- rep$sd[indsdr]
      ll <- est - zscore*sd
      ul <- est + zscore*sd
    }
    if (length(est)==0){
      ll <- NA
      ul <- NA
      sd <- NA
      est <- NA
      if (length(indopt)>0){
        est <- rep$opt$par[indopt]
      } else {
        if ('phases' %in% names(rep$inp)){
          if (parname %in% names(rep$inp$phases)){
            if (rep$inp$phases[[parname]] == -1){
              est <- rep$inp$parlist[[parname]]
              ll <- est
              ul <- est
            }
          }else {
            if (!is.na(parname) && parname == 'P'){
              B <- get.par('logB', rep, exp=TRUE, CI = CI)
              C <- get.par('logCpred', rep, exp=TRUE, CI = CI)
              ic <- rep$inp$ic
              nc <- rep$inp$nc
              B0 <- B[ic, 2]
              B1 <- B[ic+nc, 2]
              T0 <- rep$inp$time[ic]
              T1 <- rep$inp$time[ic+nc]
              # Get annual average
              est <- (B1 - B0 + C[, 2]) / (T1-T0)
            }
          }
        } else {
          warning('get.par WARNING: could not extract ', parname)
        }
      }
    }
    if (exp==TRUE){
      # This is the CV of a log-normally distributed random variable
      # see https:/ /en.wikipedia.org/wiki/Log-normal_distribution
      cv <- sqrt(exp(sd^2) - 1)
      ll <- exp(ll)
      ul <- exp(ul)
      ul[ul == Inf] <- exp(705) # Put a large but finite value instead of Inf
      est <- exp(est)
    } else {
      cv <- sd/est
    }
    out <- cbind(ll, est, ul, sd, cv)
    if (parname %in% c('logB', 'logF', 'logBBmsy', 'logFFmsy')){
      rownames(out) <- rep$inp$time
    }
    return(out)
  }
}

#' @rdname get.par
#' @export
list.quantities <- function(rep) {
  with(rep,
       sort(unique(c(names(value), names(par.fixed), names(par.random))))
  )
}



#' @name add.catchunit
#' @title Add catch unit to label
#' @param lab Base label
#' @param cu Catch unit as a character string
#' @return Label with added catch unit
add.catchunit <- function(lab, cu){
  cu <- as.character(cu)
  if (cu != ''){
    out <- eval(bquote(.(lab[[1]]) *',' ~ .(cu)))
  } else {
    out <- lab
  }
  return(out)
}


#' @name make.rpellipse
#' @title Calculate confidence ellipsis for reference points.
#' @details Calculates the confidence ellipsis of logBmsy and logFmsy (last if multiple)
#' @param rep A result report as generated by running fit.spict.
#' @return A matrix with two columns containing the x and y coordinates of the ellipsis.
#' @importFrom ellipse ellipse
make.rpellipse <- function(rep){
  inds <- c(max(which(names(rep$value)=='logBmsy')), max(which(names(rep$value)=='logFmsy')))
  sds <- rep$sd[inds]
  cova <- ( rep$sd[ which(names(rep$value)=='logBmsyPluslogFmsy') ]^2 - sds[1]^2 - sds[2]^2 )/2
  covBF <- matrix( c( sds[1]^2, cova, cova, sds[2]^2 ),2,2,byrow=TRUE)
  corBF <- cov2cor(covBF)
  parBF <- rep$value[inds]
  return(ellipse::ellipse(corBF[1,2], scale=sqrt(diag(covBF)), centre=parBF, npoints=300))
}


#' @name calc.EBinf
#' @title Calculate E(Binfinity), i.e. the fished equilibrium.
#' @details If a seasonal pattern in F is imposed the annual average F is used for calculating the expectation. Max() is used to avoid negative values.
#' @param K The carrying capacity.
#' @param n Pella-Tomlinson exponent.
#' @param Fl Average fishing mortality of the last year.
#' @param Fmsy Fishing mortality at MSY.
#' @param sdb2 Standard deviation squared (variance) of B process.
#' @return E(Binf).
calc.EBinf <- function(K, n, Fl, Fmsy, sdb2){
  max(c(0, K*(1 - (n-1)/n * Fl/Fmsy)^(1/(n-1)) * (1 - n/2/(1 - (1-n*Fmsy + (n-1)*Fl))*sdb2)))
}


#' @name get.EBinf
#' @title Calculate E(Binfinity) the fished equilibrium.
#' @details If a seasonal pattern in F is imposed the annual average F is used for calculating the expectation.
#' @param rep A result of fit.spict.
#' @return E(Binf).
get.EBinf <- function(rep){
  K <- get.par('logK', rep, exp=TRUE)[2]
  n <- get.par('logn', rep, exp=TRUE)[2]
  sdb2 <- get.par('logsdb', rep, exp=TRUE)[2]^2
  Fmsyall <- get.par('logFmsy', rep, exp=TRUE)
  Fmsy <- tail(Fmsyall, 1)
  logFest <- get.par('logFs', rep)
  if (min(rep$inp$dtc) < 1){
    alf <- annual(rep$inp$time, logFest[, 2])
    fff <- exp(alf$annvec)
  } else {
    #fff <- exp(logFest[rep$inp$indest,2])
    fff <- exp(logFest[, 2])
  }
  Fl <- tail(unname(fff), 1)
  EBinf <- calc.EBinf(K, n, Fl, Fmsy[2], sdb2)
}



#' @name get.mfrow
#' @title Get mfrow from the number of plots to be plotted
#' @param n Number of plots to be plotted.
#' @return Nothing
#' @export
get.mfrow <- function(n){
  ncol <- floor(sqrt(n))
  nrow <- ceiling(n/ncol)
  return(c(nrow, ncol))
}

#' @name add.manlines
#' @title Add lines to plot indicating result of management scenarios.
#' @param rep A result report as generated by running fit.spict.
#' @param par The name of the parameter to be plotted.
#' @param par2 If a second parameter should be used as explanatory variable instead of time.
#' @param index.shift Shift initial time point by this index.
#' @param plot.legend Logical; should the legend be plotted?
#' @param verbose Should detailed outputs be provided (default: TRUE).
#' @param \dots Passed to \code{lines}.
#' @return Nothing
#' @export
add.manlines <- function(rep, par, par2=NULL, index.shift=0, plot.legend=TRUE,
                         verbose = TRUE, ...){
  scenarios <- 1:length(rep$man)
  nman <- length(scenarios)
  errflag <- rep(FALSE,nman)
  for (i in 1:nman){
    rp <- rep$man[[scenarios[i]]]
    ip <- rp$inp
    manint <- ip$maninterval
    mandiff <- diff(manint)
    est <- get.par(par, rp, exp=TRUE)[,2]
    dtcp <- ip$dtcp
    if(par == 'logCpred'){
      time <- rp$inp$timeCpred
      lastobs <- ip$lastCatchObs
      indlastobs <- which(time == lastobs)
    }else{
      time <- rp$inp$time
      lastobs <- ip$timerangeObs[2]
      indlastobs <- which(time == lastobs)
    }
    indmanstart <- which(time >= manint[1])
    ## manperiod
    if(par == 'logCpred'){
      if(mandiff < 1){
        errflag[i] <- TRUE
        mantime <- NULL
        manc <- NULL
      }else if(mandiff > 1){
        mantime <- seq(manint[1], manint[2], 1)
        mantime <- mantime[-length(mantime)]
        manc <- rep(est[indmanstart] / mandiff, length(mantime))
      }else{
        mantime <- manint[1]
        manc <- est[indmanstart]
      }
      ## aggregate seasonal catches in man
      if(any(dtcp[indmanstart] < 1)){
        alo <- annual(time[indmanstart], est[indmanstart]/dtcp[indmanstart], mean)
        mantime <- alo$anntime
        manc <- alo$annvec
      }
      ind <- which(time < manint[1])
      preind <- tail(which(dtcp[ind] == 1),1)
      ## aggregate seasonal catches before man
      if(any(dtcp[ind] < 1)){
        alo <- annual(time[ind], est[ind]/dtcp[ind], mean)
        time <- alo$anntime
        est <- alo$annvec
        ind <- which(time < manint[1])
        dtcp <- diff(unique(c(time,manint[1])))
        preind <- which.max(time[which(dtcp >= 1)])
      }
      premantime <- time[preind]
      premanc <- est[preind]
      x <- c(premantime,mantime)
      y <- c(premanc,manc)
    }else{
      maninds <- (indmanstart[1] - index.shift):tail(indmanstart,1)
      if (is.null(par2)){
        x <- time[maninds]
      } else {
        x <- get.par(par2, rp, exp=TRUE)[maninds, 2]
      }
      y <- est[maninds]
    }
    lines(x, y, col=man.cols()[i], lwd=1.5, ...)
    ## intermediate period
    intdiff <- manint[1] - lastobs
    if(intdiff > 0 && (par != 'logCpred' || (par == 'logCpred' && intdiff %% 1 == 0))){
      ind <- which(time >= lastobs & time < manint[1])
      if(par == 'logCpred'){
        if(intdiff %% 1 == 0){
          intinds <- (ind[1] - index.shift):preind
        }
      }else{
        intinds <- (ind[1] - index.shift):maninds[1]
      }
      if (is.null(par2)){
        x <- time[intinds]
      } else {
        x <- get.par(par2, rp, exp=TRUE)[intinds, 2]
      }
      y <- est[intinds]
      lines(x, y, col=man.cols()[i], lwd=1.5, lty=3)
    }
  }
  ## legend
  nouse <- capture.output(nms <- rownames(sumspict.manage(rep, include.unc=FALSE, verbose=FALSE)$est))
  if (plot.legend){
    legend('topleft', legend=nms, lty=1, col=man.cols()[1:nman], bg='transparent', cex=0.8)
  }
  ## Note
  if (any(errflag) && verbose) cat(paste0("The management period of scenario(s): ",
                                          paste0(names(rep$man)[errflag],collapse=", "),
                                          " is shorter than 1 year. Thus, the catch cannot be displayed correctly in the annual catch plot.\n"))
}


#' @name get.manlimits
#' @title Get limts of any parameter considering all spict objects in rep$man
#' @param rep A result report as generated by running fit.spict.
#' @param par The name of the parameter to be plotted.
#' @param CI Confidence intervals to be calculated, e.g. 0.9 for the 90\%
#'     confidence intervals. By default (CI = 0.95), the 95\% confidence
#'     intervals are estimated.
#' @return plotting limits for all reps in rep$man
get.manlimits <- function(rep, par, CI = 0.95){
  scenarios <- 1:length(rep$man)
  nman <- length(scenarios)
  lims <- vector("list",nman)
  for (i in 1:nman){
    rp <- rep$man[[ scenarios[i] ]]
    if (par == 'time'){
      lims[[i]] <- range(c(rp$inp$time, tail(rp$inp$time, 1) + 0.5))
    }else{
      lims[[i]] <- get.par(par, rp, exp=TRUE)[, 2]
      if(par == "logCpred"){
        lims[[i]] <- lims[[i]] / c(diff(rp$inp$timeCpred), rp$inp$dtpredc)
      }

    }
  }
  return(range(unlist(lims)))
}

#' @name get.manmax
#' @title Get spict object in rep$man with longest time series
#' @param rep A result report as generated by running fit.spict.
#' @return rep in rep$man which hast the longest time series
get.manmax <- function(rep){
  scenarios <- 1:length(rep$man)
  nman <- length(scenarios)
  maxs <- vector("list",nman)
  for (i in 1:nman){
    ip <- rep$man[[ scenarios[i] ]]$inp
    maxs <- max(ip$ns)
  }
  repout <- rep$man[[which.max(maxs)[1]]]
  return(repout)
}


#' @name txt.stamp
#' @title Add spict version to plot
#' @param string Character string to stamp.
#' @param cex Stamp cex.
#' @param do.flag If NULL stamp will be added if not in a multi plot, i.e. mean(par()$mfrow) > 1
#' @return Nothing
#' @export
txt.stamp <- function(string = get.version(), cex=0.5, do.flag=NULL) {
  #if (string == 'undef'){
  #    string <- get.version()
  #}
  if (is.null(do.flag)){
    if (mean(par()$mfrow) > 1){
      do.flag <- FALSE
    } else {
      do.flag <- TRUE
    }
  }
  if (!is.null(string)){
    if (string != '' & !is.na(string) & do.flag){
      opar <- par(new = "TRUE", plt = c(0, 1, 0, 1), mfrow=c(1, 1), xpd=FALSE)
      on.exit(par(opar))
      plot(1, typ='n', xaxt='n', yaxt='n', xlab='', ylab='', bty='n') # Empty plot
      #opar <- par(yaxt = "s", xaxt = "s")
      on.exit(par(opar))
      plt <- par("plt")
      usr <- par("usr")
      xcoord <- usr[2] + (usr[2] - usr[1])/(plt[2] - plt[1]) * (1 - plt[2]) - 0.4 * strwidth("m")
      ycoord <- usr[3] - diff(usr[3:4])/diff(plt[3:4]) * (plt[3]) + 0.4 * strheight("m")
      if (par("xlog")){
        xcoord <- 10^(xcoord)
      }
      if (par("ylog")){
        ycoord <- 10^(ycoord)
      }
      text(xcoord, ycoord, string, adj = 1, cex=cex)
    }
  }
}


#' @name warning.stamp
#' @title Add warning sign to plot
#' @return Nothing
warning.stamp <- function(){
  opar <- par(yaxt = "s", xaxt = "s", xpd = NA)
  on.exit(par(opar))
  usr <- par("usr")
  xcoord <- usr[1]
  ycoord <- usr[4] + 0.035/diff(par()$fig[3:4]) * diff(usr[3:4])
  if (par("xlog")){
    xcoord <- 10^(xcoord)
  }
  if (par("ylog")){
    ycoord <- 10^(ycoord)
  }
  points(xcoord, ycoord, pch=24, bg='yellow', col='black', cex=2, lwd=1.5)
  text(xcoord, ycoord, '!', cex=0.8)
}


#' @name add.catchunit
#' @title Add catch unit to label
#' @param lab Base label
#' @param cu Catch unit as a character string
#' @return Label with added catch unit
add.catchunit <- function(lab, cu){
  cu <- as.character(cu)
  if (cu != ''){
    out <- eval(bquote(.(lab[[1]]) *',' ~ .(cu)))
  } else {
    out <- lab
  }
  return(out)
}


#' @name arrow.line
#' @title Draw a line with arrow heads.
#' @details Add to an existing plot a continuous line with arrow heads showing the direction between each data point
#' @param x X coordinates.
#' @param y Y coordinates.
#' @param length See documentation for arrows.
#' @param angle See documentation for arrows.
#' @param code See documentation for arrows.
#' @param col See documentation for arrows.
#' @param lty See documentation for arrows.
#' @param lwd See documentation for arrows.
#' @param ... See documentation for arrows.
#' @return Nothing, but an arrow line is added to the current plot.
arrow.line <- function(x, y, length = 0.25, angle = 30, code = 2, col = par("fg"), lty = par("lty"), lwd = par("lwd"), ...){
  n <- length(x)
  for (i in 2:n){
    arrows(x[i-1], y[i-1], x[i], y[i], length, angle, code, col, lty, lwd, ...)
  }
}


#' @name true.col
#' @title Load color of true values from simulation.
#' @return Color vector
true.col <- function() rgb(1, 165/255, 0, alpha=0.7) # 'orange'


#' @name man.cols
#' @title Load color of management scenarios.
#' @return Color vector
man.cols <- function(){
  colvec <- c('darkmagenta','cyan3','darkgreen','coral1','black',
              'magenta','gold','green','cadetblue3',
              'chocolate3', 'darkolivegreen3','cyan','darkred')
  return(rep(colvec, 3))
}


#' @name plot.col
#' @title Plot model points colored depending on the quarter to which they belong.
#' @param time Time vector.
#' @param obs Observation vector (or residual vector).
#' @param obsx Second observation vector for use as independent variable instead of time.
#' @param pch Point character.
#' @param add If TRUE plot is added to the current plot.
#' @param typ Plot type.
#' @param do.line If TRUE draw a line between points.
#' @param add.legend If TRUE add legend containing information on quarters.
#' @param add.vline.at If not NULL will draw a vertical line at the given time point.
#' @param ... Additional plotting arguments.
#' @return Nothing.
plot.col <- function(time, obs, obsx=NULL, pch=1, add=FALSE, typ='p', do.line=TRUE,
                     add.legend=FALSE, add.vline.at=NULL, ...){
  if (is.null(obsx)){
    x <- time
  } else {
    x <- obsx
  }
  nobs <- length(obs)
  mods <- time%%1
  cols <- season.cols(mods)
  if (!add){
    plot(x, obs, typ='n', ...)
  }
  if (!is.null(add.vline.at)){
    abline(v=add.vline.at, lty=3, col='gray')
  }
  if (typ=='p' & do.line){
    lines(x, obs, col='lightgray')
  }
  if (typ=='p'){
    pchs <- rep_len(1:5,pch)
    points(x, obs, col=1, pch=20+pchs[pch], bg=cols)
  }
  if (typ=='l'){
    qs <- unique(mods)
    qcols <- season.cols(qs)
    nintv <- length(qs)
    if (nintv <= 4){
      for (i in 1:nintv){
        inds <- which(qs[i] == mods)
        lines(x[inds], obs[inds], col=qcols[i], lty=1)
      }
    } else {
      lines(x, obs, col='lightgray')
      warning('More than four observed sub-annual time points (', nintv,
              '), plotting only one line.')
    }
  }
  if (add.legend){
    add.col.legend()
  }
  if (!add){
    box(lwd=1.5)
  }
}


#' @name add.col.legend.hor
#' @title Add a legend explaining colors of points (horizontal orientation)
#' @return Nothing.
add.col.legend.hor <- function(){
  pusr <- par('usr')
  mods <- seq(0, 1, length=13)
  rgbcols <- season.cols(mods)
  nbar <- length(rgbcols)-1
  barwidth <- diff(pusr[1:2])
  dbw <- barwidth/nbar
  pxmax <- pusr[2]
  pymax <- pusr[4]
  barheight <- 0.05*diff(pusr[3:4])
  barx <- pxmax-barwidth
  bary <- pymax-barheight
  for (i in 1:nbar){
    xst <- barx+(i-1)*dbw
    rect(xst,bary,xst+dbw,pymax,col=rgbcols[i],lty=0)
  }
  rect(barx,bary,pxmax,pymax)
  labx <- seq(barx, barx+barwidth, length=5)
  laby <- pusr[4]-barheight
  text(labx[1:4]+dbw/2, laby, c('Jan', 'Apr', 'Jul', 'Oct'), pos=1)
}


#' @name add.col.legend
#' @title Add a legend explaining colors of points (vertical orientation)
#' @return Nothing.
add.col.legend <- function(){
  rel <- (par()$fin/par()$pin)[2]
  yfac <- 3*rel - 3
  opar <- par(xpd=TRUE)
  on.exit(par(opar))
  pusr <- par('usr')
  mods <- seq(0, 1, length=13)
  rgbcols <- season.cols(mods)
  nbar <- length(rgbcols)-1
  barwidth <- 0.05*diff(pusr[1:2])
  barheight <- 0.1*yfac*diff(pusr[3:4])
  dbh <- barheight/nbar
  pxmax <- pusr[2]
  pymax <- pusr[4]
  barx <- pxmax-barwidth
  bary <- pymax+barheight
  for (i in 1:nbar){
    #xst <- barx+(i-1)*dbw
    yst <- bary - (i-1)*dbh
    rect(barx, yst, pxmax, yst+dbh, col=rgbcols[i], lty=0)
  }
  #rect(barx, bary, pxmax, pymax)
  laby <- seq(bary, pymax, length=5)
  labx <- pxmax
  text(labx, laby[1:4], c('Jan', 'Apr', 'Jul', 'Oct'), pos=4, cex=0.8)
}

#' @name annual
#' @title Convert from quarterly (or other sub-annual) data to annual means, sums or a custom function.
#' @param intime A time vector corresponding to the values in vec.
#' @param vec The vector of values to convert to annual means.
#' @param type item to match as function: symbol or string, see \code{\link{match.fun}} for details.
#' @return A list containing the annual means \code{$annvec} and a corresponding time vector \code{$anntime}.
#' @export
annual <- function(intime, vec, type = 'mean') {
  fun <- match.fun(type)
  anntime <- unique(floor(intime))
  nanntime <- length(anntime)
  nstepvec <- rep(0, nanntime)
  floortime <- floor(intime)
  for (i in seq(nanntime)) {
    nstepvec[i] <- sum(anntime[i] == floortime)
  }
  nsteps <- max(nstepvec)
  # Remove years that are not full
  anntime <- anntime[which(nstepvec == max(nstepvec))]
  nanntime <- length(anntime)
  annvec <- rep(0, nanntime)
  for (i in seq(nanntime)) {
    inds <- which(anntime[i] == floortime)
    annvec[i] <- fun(vec[inds])
  }
  return(list(anntime = anntime, annvec = annvec))
}


#' @name get.version
#' @title Get version of spict including git sha1 version if available.
#' @param pkg Name of package.
#' @return Package version
#' @importFrom utils packageDescription
#' @export
get.version <- function(pkg='spict'){
  pd <- utils::packageDescription(pkg)
  v <- paste0(pd$Package, "_v", pd$Version)
  if (is.null(pd$GithubRef)){
    return(v)
  } else {
    paste0(v , "@", substr(pd$GithubSHA1,1,6))
  }
}


#' @name elu_plot_kobe
#' @title Plot fishing mortality versus biomass.
#'
#' @param rep A result report as generated by running fit.spict.
#' @param logax Take log of x and y-axes? default: FALSE
#' @param plot.legend Plot legend explaining triangle.
#' @param man.legend Plot legend explaining management scenarios..
#' @param ext Add relative level axis to top and right side.
#' @param rel.axes Plot axes in relative levels instead of absolute.
#' @param xlim Limits of x-axis.
#' @param ylim Limits of y-axis.
#' @param labpos Positions of time stamps of start and end points as in pos in text().
#' @param xlabel Label of x-axis. If NULL not used.
#' @param stamp Stamp plot with this character string.
#' @param verbose Should detailed outputs be provided (default: TRUE).
#' @param CI Confidence intervals to be calculated, e.g. 0.9 for the 90\%
#'     confidence intervals. By default (CI = 0.95), the 95\% confidence
#'     intervals are estimated.
#'
#' @details
#'
#' Plots estimated fishing mortality as a function of biomass together with
#' reference points and the prediction for next year given a constant F. The
#' equilibrium biomass for F fixed to the current value is also plotted.
#'
#' The predicted trajectory (or trajectories of different management scenarios)
#' are only plotted for annnual data.
#'
#'
#' @return Nothing.
#'
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' plotspict.fb(rep)
#'
#' @export
ELU_NEW_KOBE <- function(rep, logax=FALSE, plot.legend=TRUE, man.legend=TRUE, ext=TRUE, rel.axes=FALSE,
                          xlim=NULL, ylim=NULL, labpos=c(1, 1), xlabel=NULL, stamp=get.version(),
                          verbose=TRUE, CI = 0.95){
  check.rep(rep)
  if (!'sderr' %in% names(rep)){
    #omar <- par()$mar
    mar <- c(5.1, 4.3, 4.1, 4.1)
    if (dev.cur()==1){ # If plot is not open
      opar <- par(mar=mar)
      on.exit(par(opar))
    }
    if (dev.cur()==2){ # If plot is open, check if it is a 1x1 plot
      if (all(par()$mfrow == c(1, 1))){
        opar <- par(mar=mar)
        on.exit(par(opar))
      }
    }
    log <- ifelse(logax, 'xy', '')
    inp <- rep$inp
    tvgflag <- rep$inp$timevaryinggrowth | rep$inp$logmcovflag
    if (tvgflag){
      rel.axes <- TRUE
    }
    Bmsyall <- get.par('logBmsy', rep, exp=TRUE, CI = CI)
    Fmsyall <- get.par('logFmsy', rep, exp=TRUE, CI = CI)
    Bmsy <- tail(Bmsyall, 1)
    Fmsy <- tail(Fmsyall, 1)
    if (rel.axes){
      ext <- FALSE
      bscal <- Bmsy[2]
      fscal <- Fmsy[2]
      xlab <- expression(B[t]/B[MSY])
      ylab <- expression(F[t]/F[MSY])
    } else {
      bscal <- 1
      fscal <- 1
      xlab <- expression(B[t])
      xlab <- add.catchunit(xlab, inp$catchunit)
      ylab <- expression(F[t])
    }
    Bp <- get.par('logBp', rep, exp=TRUE, CI = CI)
    Best <- get.par('logB', rep, exp=TRUE, CI = CI)
    logBest <- get.par('logB', rep, CI = CI)
    if (tvgflag){
      Fest <- get.par('logFFmsy', rep, exp=TRUE, CI = CI)
      fscal <- 1
      Fmsy <- c(1, 1)
    } else {
      Fest <- get.par('logFs', rep, exp=TRUE, CI = CI)
    }
    logFest <- get.par('logFs', rep, CI = CI)
    ns <- dim(Best)[1]
    Fp <- Fest[ns,]
    ##inds <- c(max(which(names(rep$value)=='logBmsy')), max(which(names(rep$value)=='logFmsy')))
    ##if (rep$opt$convergence == 0 & rep$inp$getReportCovariance & !tvgflag){
    if (rep$opt$convergence == 0 & !tvgflag & requireNamespace("ellipse", quietly = TRUE)) {
      cl <- try(make.rpellipse(rep))
    } else {
      cl <- numeric()
      class(cl) <- 'try-error'
    }
    if (class(cl)[1] == 'try-error'){
      cl <- matrix(c(log(Bmsy[2]), log(Fmsy[2])), 1, 2)
    }
    if (min(inp$dtc) < 1){ # Quarterly
      alb <- annual(inp$time, logBest[, 2])
      alf <- annual(inp$time, logFest[, 2])
      aind <- which(inp$time[inp$dtprediind] == alb$anntime)
      bbb <- exp(alb$annvec)/bscal
      fff <- exp(alf$annvec)/fscal
      fbtime <- alb$anntime
    } else {
      fff <- Fest[inp$indest, 2]/fscal
      bbb <- Best[inp$indest, 2]/bscal
      pind <- rep$inp$dtprediind
      fbtime <- inp$time[inp$indest]
    }
    Fl <- tail(unname(fff), 1)
    Bl <- tail(unname(bbb), 1)
    EBinf <- get.EBinf(rep)/bscal
    # Limits
    if (is.null(xlim)){
      xlim <- range(c(exp(cl[,1]), Best[,2], EBinf)/bscal, na.rm=TRUE)
      if (min(inp$dtc) < 1){
        # New annual limits
        xlim <- range(c(exp(alb$annvec), exp(cl[, 1]), EBinf)/bscal, na.rm=TRUE)
      }
      xlim[2] <- min(c(xlim[2], 8*Bmsy[2]/bscal), 2.2*max(bbb), na.rm=TRUE)
      xlim[2] <- max(c(xlim[2], Bmsy[2]/bscal), na.rm=TRUE)
    }
    if (is.null(ylim)){
      ylim <- range(c(exp(cl[,2]), Fest[,2])/fscal, na.rm=TRUE)
      if (min(inp$dtc) < 1){
        # New annual limits
        ylim <- range(c(exp(alf$annvec)/fscal, exp(cl[, 2])/fscal), na.rm=TRUE)
      }
      ylim[2] <- min(c(ylim[2], 8*Fmsy[2]/fscal), 2.2*max(fff), na.rm=TRUE)
      ylim[2] <- max(c(ylim[2], Fmsy[2]/fscal), na.rm=TRUE)
      if ('man' %in% names(rep)){
        ylim <- range(ylim, 0)
      }
    }
    logminval <- 1e-4
    if (logax){ # Ensure that zero is not in the limit if taking log
      xlim[1] <- max(xlim[1], logminval)
      ylim[1] <- max(ylim[1], logminval)
    }
    # Plotting
    if (!is.null(xlabel)){
      xlab <- xlabel
    }
    plot(Bmsy[2]/bscal, Fmsy[2]/fscal, typ='n', xlim=xlim, xlab=xlab, ylab=ylab, ylim=ylim, log=log)
    if (ext){
      if (logax){
        expx <- pretty(log10(xlim/Bmsy[2]))
        expy <- pretty(log10(ylim/Fmsy[2]))
        labx <- 10^expx
        laby <- 10^expy
      } else {
        labx <- pretty(xlim/Bmsy[2])
        laby <- pretty(ylim/Fmsy[2])
      }
      atx <- labx*Bmsy[2] #expression(10^expx)
      aty <- laby*Fmsy[2] #expression(10^expy)
      axis(3, labels=labx, at=atx)
      mtext(expression(B[t]/B[MSY]), side=3, las=0, line=2, cex=par('cex'))
      axis(4, labels=laby, at=aty)
      mtext(expression(F[t]/F[MSY]), side=4, las=0, line=2.5, cex=par('cex'))
    }
    alpha <- 0.15
    ymin <- ifelse(logax, logminval*1e-2, -10)
    xmin <- ifelse(logax, logminval*1e-2, xlim[1]-xlim[2])
    polygon(c(Bmsy[2]/bscal, Bmsy[2]/bscal, xlim[2]*2, xlim[2]*2),
            c(Fmsy[2], ymin, ymin, Fmsy[2])/fscal, col=rgb(0.5,0.8,0.4,1), border=NA) # Green
    yel <- rgb(1,0.925,0.55,1) # Yellow
    polygon(c(Bmsy[2]/bscal, Bmsy[2]/bscal, xmin, xmin),
            c(Fmsy[2], ymin, ymin, Fmsy[2])/fscal, col=yel, border=NA) # Yellow
    polygon(c(Bmsy[2]/bscal, Bmsy[2]/bscal, xlim[2]*2, xlim[2]*2),
            c(Fmsy[2], (ylim[2]+1)*2, (ylim[2]+1)*2, Fmsy[2])/fscal, col=yel, border=NA) # Yellow
    polygon(c(Bmsy[2]/bscal, Bmsy[2]/bscal, xmin, xmin),
            c(Fmsy[2], (ylim[2]+1)*2, (ylim[2]+1)*2, Fmsy[2])/fscal, col=rgb(1,0.188,0.188,1),
            border=NA) # Red
    abline(v=0, col='darkred', lty=2)
    cicol <- 'lightgray'
    cicolrgb <- col2rgb(cicol)/255
    cicoluse <- rgb(cicolrgb[1], cicolrgb[2], cicolrgb[3], 0.7)
    cicol2 <- 'gray'
    cicol2rgb <- col2rgb(cicol2)/255
    cicol2use <- rgb(cicol2rgb[1], cicol2rgb[2], cicol2rgb[3], 0.7)
    polygon(exp(cl[,1])/bscal, exp(cl[,2])/fscal, col=cicoluse, border=cicol2use)
    if ('true' %in% names(inp)){
      points(inp$true$Bmsy/bscal, inp$true$Fmsy/fscal, pch=25, bg=true.col())
    }
    maincol <- rgb(0,0,1,0.8)
    if (min(inp$dtc) < 1){
      lines(bbb, fff, col=maincol, lwd=1.5)
    } else {
      lines(bbb, fff, col=maincol, lwd=1.5)
      if ('man' %in% names(rep)){
        add.manlines(rep, 'logF', par2='logB', index.shift=1, plot.legend=man.legend, verbose=verbose)
      }else{
        lines(Best[inp$indpred,2]/bscal, Fest[inp$indpred,2]/fscal, col=maincol, lty=3)
        Bll <- tail(Best[inp$indpred,2]/bscal, 1)
        Fll <- tail(Fest[inp$indpred,2]/fscal, 1)
        lines(c(Bll, EBinf), rep(Fll, 2), lwd=1.5, lty=3, col='blue')
        points(EBinf, Fll, pch=23, bg='gold')
      }
    }
    nr <- length(inp$ini$logr)
    if (nr > 1){
      points(Bmsyall[1:(nr-1), 2]/bscal, Fmsyall[1:(nr-1), 2]/fscal, pch=3, col='magenta')
      points(Bmsyall[nr, 2]/bscal, Fmsyall[nr, 2]/fscal, pch=3, col='black')
    }
    if (plot.legend){
      if (nr > 1){
        legend('topright', c('Current MSY', 'Previous MSY'), pch=3,
               col=c('black', 'magenta'), bg='transparent')
      } else {
        if ('true' %in% names(inp)){
          if (min(inp$dtc) < 1){
            legend('topright', 'True', pch=25, pt.bg=true.col(), bg='white')
          } else {
            legend('topright', c(expression('E(B'[infinity]*')'), 'True'),
                   pch=c(23, 25), pt.bg=c('gold', true.col()), bg='transparent')
          }
        } else {
          if (!min(inp$dtc) < 1){
            legend('topright', expression('E(B'[infinity]*')'),
                   pch=23, pt.bg='gold', bg='transparent')
          }
        }
      }
    }
    points(bbb[1], fff[1], pch=21, bg='white')
    text(bbb[1], fff[1], round(fbtime[1], 2), pos=labpos[1], cex=0.75, offset=0.5, xpd=TRUE)
    points(Bl, Fl, pch=22, bg='white')
    text(Bl, Fl, round(tail(fbtime, 1), 2), pos=labpos[2], cex=0.75, offset=0.5, xpd=TRUE)
    box(lwd=1.5)
    if (rep$opt$convergence != 0){
      warning.stamp()
    }
    #txt.stamp(stamp)
  }
}














