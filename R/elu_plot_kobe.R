#' @name elu_plot_kobe
#' @title Plot fishing mortality versus biomass.
#'
#' @param rep A result report as generated by running fit.spict.
#' @param logax Take log of x and y-axes? default: FALSE
#' @param plot.legend Plot legend explaining triangle.
#' @param man.legend Plot legend explaining management scenarios..
#' @param ext Add relative level axis to top and right side.
#' @param rel.axes Plot axes in relative levels instead of absolute.
#' @param xlim Limits of x-axis.
#' @param ylim Limits of y-axis.
#' @param labpos Positions of time stamps of start and end points as in pos in text().
#' @param xlabel Label of x-axis. If NULL not used.
#' @param stamp Stamp plot with this character string.
#' @param verbose Should detailed outputs be provided (default: TRUE).
#' @param CI Confidence intervals to be calculated, e.g. 0.9 for the 90\%
#'     confidence intervals. By default (CI = 0.95), the 95\% confidence
#'     intervals are estimated.
#'
#' @details
#'
#' Plots estimated fishing mortality as a function of biomass together with
#' reference points and the prediction for next year given a constant F. The
#' equilibrium biomass for F fixed to the current value is also plotted.
#'
#' The predicted trajectory (or trajectories of different management scenarios)
#' are only plotted for annnual data.
#'
#'
#' @return Nothing.
#'
#' @examples
#' data(pol)
#' rep <- fit.spict(pol$albacore)
#' plotspict.fb(rep)
#'
#' @export
elu_plot_kobe <- function(rep, logax=FALSE, plot.legend=TRUE, man.legend=TRUE, ext=TRUE, rel.axes=FALSE,
                         xlim=NULL, ylim=NULL, labpos=c(1, 1), xlabel=NULL, stamp=get.version(),
                         verbose=TRUE, CI = 0.95){
  check.rep(rep)
  if (!'sderr' %in% names(rep)){
    #omar <- par()$mar
    mar <- c(5.1, 4.3, 4.1, 4.1)
    if (dev.cur()==1){ # If plot is not open
      opar <- par(mar=mar)
      on.exit(par(opar))
    }
    if (dev.cur()==2){ # If plot is open, check if it is a 1x1 plot
      if (all(par()$mfrow == c(1, 1))){
        opar <- par(mar=mar)
        on.exit(par(opar))
      }
    }
    log <- ifelse(logax, 'xy', '')
    inp <- rep$inp
    tvgflag <- rep$inp$timevaryinggrowth | rep$inp$logmcovflag
    if (tvgflag){
      rel.axes <- TRUE
    }
    Bmsyall <- get.par('logBmsy', rep, exp=TRUE, CI = CI)
    Fmsyall <- get.par('logFmsy', rep, exp=TRUE, CI = CI)
    Bmsy <- tail(Bmsyall, 1)
    Fmsy <- tail(Fmsyall, 1)
    if (rel.axes){
      ext <- FALSE
      bscal <- Bmsy[2]
      fscal <- Fmsy[2]
      # NEW:
      xlab <- expression(B[t]/B[MSY])
      ylab <- expression(F[t]/F[MSY])
    } else {
      bscal <- 1
      fscal <- 1
      xlab <- expression(B[t])
      xlab <- add.catchunit(xlab, inp$catchunit)
      ylab <- expression(F[t])
    }
    Bp <- get.par('logBp', rep, exp=TRUE, CI = CI)
    Best <- get.par('logB', rep, exp=TRUE, CI = CI)
    logBest <- get.par('logB', rep, CI = CI)
    if (tvgflag){
      Fest <- get.par('logFFmsy', rep, exp=TRUE, CI = CI)
      fscal <- 1
      Fmsy <- c(1, 1)
    } else {
      Fest <- get.par('logFs', rep, exp=TRUE, CI = CI)
    }
    logFest <- get.par('logFs', rep, CI = CI)
    ns <- dim(Best)[1]
    Fp <- Fest[ns,]
    ##inds <- c(max(which(names(rep$value)=='logBmsy')), max(which(names(rep$value)=='logFmsy')))
    ##if (rep$opt$convergence == 0 & rep$inp$getReportCovariance & !tvgflag){
    if (rep$opt$convergence == 0 & !tvgflag & requireNamespace("ellipse", quietly = TRUE)) {
      cl <- try(make.rpellipse(rep))
    } else {
      cl <- numeric()
      class(cl) <- 'try-error'
    }
    if (class(cl)[1] == 'try-error'){
      cl <- matrix(c(log(Bmsy[2]), log(Fmsy[2])), 1, 2)
    }
    if (min(inp$dtc) < 1){ # Quarterly
      alb <- annual(inp$time, logBest[, 2])
      alf <- annual(inp$time, logFest[, 2])
      aind <- which(inp$time[inp$dtprediind] == alb$anntime)
      bbb <- exp(alb$annvec)/bscal
      fff <- exp(alf$annvec)/fscal
      fbtime <- alb$anntime
    } else {
      fff <- Fest[inp$indest, 2]/fscal
      bbb <- Best[inp$indest, 2]/bscal
      pind <- rep$inp$dtprediind
      fbtime <- inp$time[inp$indest]
    }
    Fl <- tail(unname(fff), 1)
    Bl <- tail(unname(bbb), 1)
    EBinf <- get.EBinf(rep)/bscal
    # Limits
    if (is.null(xlim)){
      xlim <- range(c(exp(cl[,1]), Best[,2], EBinf)/bscal, na.rm=TRUE)
      if (min(inp$dtc) < 1){
        # New annual limits
        xlim <- range(c(exp(alb$annvec), exp(cl[, 1]), EBinf)/bscal, na.rm=TRUE)
      }
      xlim[2] <- min(c(xlim[2], 8*Bmsy[2]/bscal), 2.2*max(bbb), na.rm=TRUE)
      xlim[2] <- max(c(xlim[2], Bmsy[2]/bscal), na.rm=TRUE)
    }
    if (is.null(ylim)){
      ylim <- range(c(exp(cl[,2]), Fest[,2])/fscal, na.rm=TRUE)
      if (min(inp$dtc) < 1){
        # New annual limits
        ylim <- range(c(exp(alf$annvec)/fscal, exp(cl[, 2])/fscal), na.rm=TRUE)
      }
      ylim[2] <- min(c(ylim[2], 8*Fmsy[2]/fscal), 2.2*max(fff), na.rm=TRUE)
      ylim[2] <- max(c(ylim[2], Fmsy[2]/fscal), na.rm=TRUE)
      if ('man' %in% names(rep)){
        ylim <- range(ylim, 0)
      }
    }
    logminval <- 1e-4
    if (logax){ # Ensure that zero is not in the limit if taking log
      xlim[1] <- max(xlim[1], logminval)
      ylim[1] <- max(ylim[1], logminval)
    }
    # Plotting
    if (!is.null(xlabel)){
      xlab <- xlabel
    }
    plot(Bmsy[2]/bscal, Fmsy[2]/fscal, typ='n', xlim=xlim, xlab=xlab, ylab=ylab, ylim=ylim, log=log)
    if (ext){
      if (logax){
        expx <- pretty(log10(xlim/Bmsy[2]))
        expy <- pretty(log10(ylim/Fmsy[2]))
        labx <- 10^expx
        laby <- 10^expy
      } else {
        labx <- pretty(xlim/Bmsy[2])
        laby <- pretty(ylim/Fmsy[2])
      }
      atx <- labx*Bmsy[2] #expression(10^expx)
      aty <- laby*Fmsy[2] #expression(10^expy)
      axis(3, labels=labx, at=atx)
      # NEW:
      mtext(expression(B[t]/B[MSY]), side=3,  las=0, line=2,   cex=par('cex'))
      axis(4, labels=laby, at=aty)
      mtext(expression(F[t]/F[MSY]), side=4,  las=0, line=2.5, cex=par('cex'))
    }
    alpha <- 0.15
    ymin <- ifelse(logax, logminval*1e-2, -10)
    xmin <- ifelse(logax, logminval*1e-2, xlim[1]-xlim[2])
    polygon(c(Bmsy[2]/bscal, Bmsy[2]/bscal, xlim[2]*2, xlim[2]*2),
            c(Fmsy[2], ymin, ymin, Fmsy[2])/fscal, col=rgb(0.5,0.8,0.4,1), border=NA) # Green
    yel <- rgb(1,0.925,0.55,1) # Yellow
    polygon(c(Bmsy[2]/bscal, Bmsy[2]/bscal, xmin, xmin),
            c(Fmsy[2], ymin, ymin, Fmsy[2])/fscal, col=yel, border=NA) # Yellow
    polygon(c(Bmsy[2]/bscal, Bmsy[2]/bscal, xlim[2]*2, xlim[2]*2),
            c(Fmsy[2], (ylim[2]+1)*2, (ylim[2]+1)*2, Fmsy[2])/fscal, col=yel, border=NA) # Yellow
    polygon(c(Bmsy[2]/bscal, Bmsy[2]/bscal, xmin, xmin),
            c(Fmsy[2], (ylim[2]+1)*2, (ylim[2]+1)*2, Fmsy[2])/fscal, col=rgb(1,0.188,0.188,1),
            border=NA) # Red
    abline(v=0, col='darkred', lty=2)
    cicol <- 'lightgray'
    cicolrgb <- col2rgb(cicol)/255
    cicoluse <- rgb(cicolrgb[1], cicolrgb[2], cicolrgb[3], 0.7)
    cicol2 <- 'gray'
    cicol2rgb <- col2rgb(cicol2)/255
    cicol2use <- rgb(cicol2rgb[1], cicol2rgb[2], cicol2rgb[3], 0.7)
    polygon(exp(cl[,1])/bscal, exp(cl[,2])/fscal, col=cicoluse, border=cicol2use)
    if ('true' %in% names(inp)){
      points(inp$true$Bmsy/bscal, inp$true$Fmsy/fscal, pch=25, bg=true.col())
    }
    maincol <- rgb(0,0,1,0.8)
    if (min(inp$dtc) < 1){
      lines(bbb, fff, col=maincol, lwd=1.5)
    } else {
      lines(bbb, fff, col=maincol, lwd=1.5)
      if ('man' %in% names(rep)){
        add.manlines(rep, 'logF', par2='logB', index.shift=1, plot.legend=man.legend, verbose=verbose)
      }else{
        lines(Best[inp$indpred,2]/bscal, Fest[inp$indpred,2]/fscal, col=maincol, lty=3)
        Bll <- tail(Best[inp$indpred,2]/bscal, 1)
        Fll <- tail(Fest[inp$indpred,2]/fscal, 1)
        lines(c(Bll, EBinf), rep(Fll, 2), lwd=1.5, lty=3, col='blue')
        points(EBinf, Fll, pch=23, bg='gold')
      }
    }
    nr <- length(inp$ini$logr)
    if (nr > 1){
      points(Bmsyall[1:(nr-1), 2]/bscal, Fmsyall[1:(nr-1), 2]/fscal, pch=3, col='magenta')
      points(Bmsyall[nr, 2]/bscal, Fmsyall[nr, 2]/fscal, pch=3, col='black')
    }
    if (plot.legend){
      if (nr > 1){
        legend('topright', c('Current MSY', 'Previous MSY'), pch=3,
               col=c('black', 'magenta'), bg='transparent')
      } else {
        if ('true' %in% names(inp)){
          if (min(inp$dtc) < 1){
            legend('topright', 'True', pch=25, pt.bg=true.col(), bg='white')
          } else {
            legend('topright', c(expression('E(B'[infinity]*')'), 'True'),
                   pch=c(23, 25), pt.bg=c('gold', true.col()), bg='transparent')
          }
        } else {
          if (!min(inp$dtc) < 1){
            legend('topright', expression('E(B'[infinity]*')'),
                   pch=23, pt.bg='gold', bg='transparent')
          }
        }
      }
    }
    points(bbb[1], fff[1], pch=21, bg='white')
    text(bbb[1], fff[1], round(fbtime[1], 2), pos=labpos[1], cex=0.75, offset=0.5, xpd=TRUE)
    points(Bl, Fl, pch=22, bg='white')
    text(Bl, Fl, round(tail(fbtime, 1), 2), pos=labpos[2], cex=0.75, offset=0.5, xpd=TRUE)
    box(lwd=1.5)
    if (rep$opt$convergence != 0){
      warning.stamp()
    }
    #txt.stamp(stamp)
  }
}
